---
layout:     post
title:      "Gcov/Lcov"
subtitle:   " \"Gcov/Lcov: collect C coverage\""
date:       2021-05-31 19：26
author:     "Jack-C"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - Coverage
    - Testing
typora-root-url: .
---

# Abstract

> Gcov 是gcc自带的收集C语言的coverage的tool。但是由于结果是纯文本表示形式，对于想从直观上看看coverage的小朋友带来了难度。因此，Lcov诞生，通过生成HTML格式文件，有很nice的UI，方便直观分析。



 

# Gcov使用方法

注：对于机器有gcc的小伙伴不需要安装哦

## 1. 使用gcc编译程序

假装原始文件：test.c

```bash
# gcc test.c -o test   # 这种方式生成的可执行文件不能用于覆盖啊,必须用下面的语句
gcc -fprofile-arcs -ftest-coverage test.c -o test  ## 使用这种方法
```

生成文件：

test :  可执行文件

test.gcno : 估计是存储代码结构信息的，不可删除！



## 2. 运行程序

```
./test  #必须运行，不运行没有接下来的coverage没有结果，可以多次运行哦。覆盖信息也会叠加。不是被覆盖哦
```

生成文件： `test.gcda`  存储覆盖信息的二进制文件

**注意：** 重新生成覆盖信息，删除之前的所有覆盖信息，只需要晒出文件`test.gcda`.

## 3. 生成覆盖信息

```
gcov test
```

生成的文件： `test.c.gcov` 文件，文本文件，可以直接查看

![image-20210531170403338](/../img/2021-05-31-Coverage/image-20210531170403338.png)

解释：

* 不是合理的代码行
* \#### 没覆盖
* 1 ：覆盖次数



# Lcov使用方法（optional）

> 参考文献：[关于代码覆盖lcov的使用 - 简书 (jianshu.com)](https://www.jianshu.com/p/a42bbd9de1b7)

## 1. 下载&安装（源码安装）【可能Linux系统自带？】

下载地址： [lcov-1.14.tar.gz]（http://downloads.sourceforge.net/ltp/lcov-1.14.tar.gz）

解压： tar -zxvf lcov-1.14.tar.gz

安装方法： `make install`



## 2. 运行

```bash
lcov -c -i -d ./build -o init.info  # 初始化并创造基准数据
# step 2:执行编译后的文件，生成.gcov文件
# step 3: 收集覆盖
lcov -c -o test.info -d .
# step 4: 合并基准文件和执行文件后生活才能的覆盖率数据
lcov -a init.info -a cover.info -o total.info # -a 合并文件
# step 5 过滤不需要关注的源文件路径和信息

# --remove 删除统计信息中如下的代码或文件，支持正则
lcov --remove total.info '*/usr/include/*' '*/usr/lib/*' '*/usr/lib64/*' '*/usr/local/include/*' '*/usr/local/lib/*' '*/usr/local/lib64/*' '*/third/*' 'testa.cpp' -o final.info

```

- -c 生成覆盖率信息
- -o 生成目标文件
- -d 目录
- . 当前目录

## 3 文件过滤

![image-20210810124157832](/../img/2021-05-31-Coverage/image-20210810124157832.png)

## 4. 可视化

```shell
genhtml test.info -o ./output  
```

* test.info 需要生成覆盖信息的源文件
* 输出HTML到output**目录**

![image-20210531170827755](/../img/2021-05-31-Coverage/image-20210531170827755.png)





## 通过Make组织的大项目如何获取覆盖

> Make通过调用gcc，实现复杂项目的编译目的，通过编译大项目的时候，需要在**makefile**文件中传递 `-fprofile-arcs -ftest-coverage` 参数给gcc

鸣谢： [博客](https://blog.csdn.net/LU_ZHAO/article/details/104516935)

1. 在makefile中添加如下代码(定义宏)

```shell
ifeq ($(coverage), yes)
CXXFLAGS       +=  -fprofile-arcs -ftest-coverage
LINKERCXX      +=  -fprofile-arcs -ftest-coverage
OPT_FLAGS     =  -g3
endif
```

这样，可以使用 make coverage=yes 来引入这些编译选项而不会影响到正常的编译



覆盖率产生的过程如下面三个步骤所示：

1. 编译链接带覆盖率参数的源代码；
2. 运行测试程序；
3. 使用gcov获取文本形式的覆盖率数据或使用lcov获取html形式的覆盖率数据；





## 通过CMakeList组织配置文件

> CMakeLists.txt文件作为编译的配置文件，所以只需要更改CMakeList的内容

在CMakeLists文件中添加如下内容

```shell
set(CMAKE_CXX_FLAGS "-Wall -ftest-coverage -fprofile-arcs")           # this is for LLVM gcov 
set(CMAKE_CXX_OUTPUT_EXTENSION_REPLACE ON)

# 如下可选？？？不知道
SET(GCC_COVERAGE_LINK_FLAGS    "-coverage -lgcov")
SET(CMAKE_EXE_LINKER_FLAGS  "${CMAKE_EXE_LINKER_FLAGS} ${GCC_COVERAGE_LINK_FLAGS}" )



# 推荐使用这个！！！
SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fprofile-arcs -ftest-coverage") 
SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -fprofile-arcs -ftest-coverage")
```









## 补充

![image-20210613130506307](/../img/2021-05-31-Coverage/image-20210613130506307.png)





### llvm-cov 和lcov一起使用

> lcov默认和gcov一起使用，若使用llvm-cov生成覆盖信息，需要使用llvm-cov生成覆盖，否则会报错： 版本gcov版本不一致。需要如何操作

Thanks： http://logan.tw/posts/2015/04/28/check-code-coverage-with-clang-and-lcov/#create-a-wrapper-script-for-lcov

先把llvm-cov gcov 命令封装成独立脚本脚本。然后在使用lcov命令的时候添加参数 **--gcov-tool**

### 开启lcov的branch coverage

> 默认lcov关闭branch coverage，开启方法两种，一种配置文件，二：命令行

方法一：配置文件[.lcovrc文件]  据说再~/.lcovrc 文件，感觉在运行的当前目录下才能启用，待检测！

```shell
# Include branch coverage data display (can be disabled by the
# --no-branch-coverage option of genhtml)
genhtml_branch_coverage = 1

# Specify if branch coverage data should be collected and processed.
lcov_branch_coverage = 1
```





方法二：命令行

```powershell
lcov --rc lcov_branch_coverage=1 -c -d ./ -o test.info  # --rc lcov_branch_coverage=1
```



